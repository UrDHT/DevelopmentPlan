\documentclass[11pt,conference]{IEEEtran}

\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}


\usepackage{subcaption}
%\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
\usepackage{algorithm} 
\usepackage{algorithmic}
\usepackage[font=small]{caption}

\title{UrDHT: A Unified Model for Distributed Hash Tables}



\author{\IEEEauthorblockN{Andrew Rosen \qquad Brendan Benshoof \qquad Robert W. Harrison \qquad Anu G. Bourgeois}
	\IEEEauthorblockA{Department of Computer Science\\
		Georgia State University\\
		Atlanta, Georgia\\
		rosen@cs.gsu.edu \qquad  bbenshoof@cs.gsu.edu  \qquad rharrison@cs.gsu.edu \qquad anu@cs.gsu.edu }
}

\hyphenation{op-tical net-works semi-conduc-tor Chord-Reduce Map-Reduce Data-Nodes Name-Nodes Ur-DHT Ur-CHORD}


\begin{document}
\maketitle
%TODO Actual number of functions
\begin{abstract}
	UrDHT is an abstracted Distributed Hash Table (DHT).
	By completing a few simple functions, a developer can implement the topology of any DHT.
	
	Current distributed systems suffer from fragmentation, high overhead, and an inability to scale due to difficulty of adoption.
	UrDHT is P2P system designed to improve the adaptability of P2P distributed serves.
\end{abstract}

\section{Introduction}

Distributed Hash Tables (DHT) have been extensively researched for the past decade.
Many different DHT protocols have developed over the years.
%What is a DHT
% Mention the DHT API
Despite this, no one has created a cohesive formal specification for building a DHT. % or something


UrDHT is our specification and implementation of an abstract DHT.


\subsection*{Motivation}
\label{sec:motivation}

\subsubsection{Abstraction}

Distributed Hash Tables have been the catalyst for the creation of many P2P applications.
Among these are Redis, Freenet \cite{freenet}, and, most notably, BitTorrent \cite{bittorrent}.  %TODO Add actual citations
All DHTs use roughly the same protocol to perform lookup, storage, and retrieval operations.
Despite this, no one has created a cohesive formal specification for building a DHT.

Our initial primary motivation for this project was to create an abstracted Distributed Hash Table based on observations we made during previous research \cite{dgvh}.
We discovered that all DHTs can cleanly map to the primal-dual 

\subsubsection{Bootstrapping}
One issue in the adoption of new P2P applications is the bootstrapping problem.
A node can only join the network if it knows another node \textit{that is already a member of the network it is trying to join.}


The other motivation is making it easier for users to create distributed applications.
What topology do you use?
How do we want our program to communicate over the network?


UrDHT exists to simplify this process, minimizing the distributed application development time and making it easier to adopt by creating a network to bootstrap \textit{other networks}.


\subsubsection{Embedding}






%TODO DO THIS FIRST
\begin{itemize}
	\item We first discuss our motivation for creating UrDHT and \textit{creating it the way we did}  (Section \ref{sec:motivation}).
	\item We give a formal specification for what needs to be defined in order to create a functioning DHT.
	While there has long existed a well known protocol for distributed hash tables, these define what a DHT needs to be able to do.
	It does not describe what a DHT is.
	We define a set of simple functions that are needed to implement a DHT.
	We show that using these functions, DHTs cleanly map to the primal-dual problem of Delaunay triangulations and Voronoi tessellations (Section \ref{sec:define}).
	\item We present UrDHT as an abstract DHT and show how a developer can tweak the functions we defined to create an arbitrary new DHT topology.
	We show how to reproduce the topology of Chord and Kademlia using UrDHT, which we call UrChord and UrKademlia.
	\item We conduct experiments showing that UrChord sufficiently approximates a correct implementation of Chord.
\end{itemize}


\section{What Defines a DHT}
\label{sec:define}

A distributed hash table is usually defined by its protocol; in other words, what it can do.
Nodes and data in a distributed hash table are assigned unique\footnote{Unique with astronomically high probability, given a large enough consistent hash algorithm.} keys via a consistent hashing algorithm.
To make it easier to grok the context, we will call the key associated with a node its ID and refer to  nodes and their IDs interchangeably.

A DHT can perform the \texttt{lookup(key)}, \texttt{get(key)}, and \texttt{store(key, value)} operations. \footnote{There is typically a \textit{delete(key)} operation defined too, but it is not strictly necessary.}.
The \texttt{lookup }operation returns the node responsible for a queried key, \texttt{get} returns the value stored with that key with the \texttt{store} function.

However, this is what a DHT \textit{does}, viewing the DHT as a black box, not what a DHT \textit{is} and needs to be implemented.
Here, we open that black box for the first time and present those components.
We show that Distributed Hash Tables are just Voronoi tessellations and Delaunay triangulation.


\subsection{DHT Components}
The following functions need to be defined in order for nodes to perform lookup operations and determine responsibility.
\begin{itemize}
	\item \textbf{A \texttt{distance} function } - 
	This measures distance in the overlay formed by the Distributed Hash Table.
	In most DHTs, the distance in the overlay has no correlation with real-world attributes.
	This is not necessarily the case with UrDHT (see Section \ref{sec:hyper}).
	
	\item \textbf{A \texttt{midpoint} function} - This calculates the minimally equidistant point between two given point.
	The midpoint is required for Delaunay triangulation calculation.
	In some spaces, such as Kademlia's XOR metric space, this can be tricky to calculate.  % Is this part of ownership?
	\item \textbf{An \texttt{responsibility} definition}  This defines the range of keys a node is responsible for. 
	Not every DHT defines which node is responsible for particular keys in the same way. 
	For example, nodes in Kademlia are responsible for the keys closest to themselves, while in Chord, nodes are responsible for the keys falling between themselves and the preceding node.
\end{itemize}


A DHT also needs a strategy to organize and maintain two lists of of other nodes in the network: \textit{short peers} and \textit{long peers}.
Short peers are the set of peers that define the topology of the network and guarantee that greedy routing works.

Long peers allow the DHT to achieve a better than linear lookup time, typically $ \log(n) $, where $n$ is the size of the network. 

Interestingly, despite the diversity of DHT topologies, all DHTs use the relatively the greedy routing algorithm (Algorithm X):

\begin{algorithm}
	\caption{The DHT Generic Routing algorithm}
	\label{alg:routing}
	\algsetup{linenosize=\tiny}
	\begin{algorithmic}[1]
		\STATE Given node $n$ and a message being sent to $key$
		\STATE \textbf{function} $n.$\texttt{lookup}$(key)$
		\IF{If $key \in n$'s range of responsibility}
			\RETURN $ n $
		\ENDIF
		\IF{ One of $n$'s short peers are responsible for $key$}
			\RETURN the responsible node
		\ENDIF
		\STATE $ candidates $ = $ short\_peers $ + $ long\_peers $
		\STATE $ next  \leftarrow $  $\min (n$.distance($candidates$, $ key ))$
		\RETURN $next.$lookup($key$)
	\end{algorithmic}
	
	\scriptsize
\end{algorithm}
If I, the node, am responsible for the key, I return myself.
Otherwise, if I know who is responsible for this key, I return that node.
Finally, if that is not the case, I forward this query to the node I know with shortest distance from the node to the desired key.\footnote{This order matters, as Chord is unidirectional.} 

Between individual DHTs, this algorithm might be implemented either recursively or iteratively.
It will certainly have differences in how a node handles errors, such as how to handle connecting to a failed node which no longer exists.
This algorithm may possibly be  run in parallel, such as in Kademlia \cite{kademlia}.
Despite this, the base greedy algorithm is always the same between implementations.

The final component is a consistent hashing function.
This function must generate keys large enough to make the chances of a hash collision nigh impossible.
%LEAD INTO MULTIHASH GOES HERE

\subsection{DHTs, Delaunay Triangulation, and Voronoi Tesselation}
With the following components of a DHT defined above we can now show the relationship between DHTs and the primal-dual problems of Delaunay Triangulation and Voronoi Tessellation.


We can map a given node's ID to a point in a space, the range of keys a node is responsible for to that node's Voronoi region, and the set of short peers to the Delaunay triangulation.
Thus, if we can calculate the Delaunay triangulation between nodes in a DHT, we have a generalized means of created the overlay network.


So how do we efficiently calculate Delaunay Triangulations in a distributed system?
We created an algorithm call the Distributed Greedy Voronoi Heuristic (DGVH), shown in Algorithm \ref{alg:dgvh} and explained below \cite{dgvh}.


\begin{algorithm} % make smaller
	\caption{Distributed Greedy Voronoi Heuristic}
	\label{alg:dgvh}
	\algsetup{linenosize=\tiny}
	%\scriptsize
	\begin{algorithmic}[1]  % the numberis how many lines
		\STATE Given node $n$ and its list of $candidates$.
		\STATE Given the minimum $table\_size$
		\STATE $short\_peers \leftarrow$ empty set that will contain $n$'s one-hop peers
		\STATE $long\_peers \leftarrow$ empty set that will contain $n$'s peers further than one hop.
		\STATE Sort $candidates$ in ascending order by each node's \texttt{distance} to $n$
		\STATE Remove the first member of $candidates$ and add it to $short\_peers$
		\FORALL{$c$ in $candidates$}
			\STATE $m$ $ \leftarrow $ \texttt{midpoint}$( n, c )$
			\IF{any node in $short\_peers$ is closer to $m$ than $n$}
				\STATE Reject $c$ as a peer
			\ELSE
				\STATE Remove $c$ from $candidates$
				\STATE Add $c$ to $short\_peers$
			\ENDIF
		\ENDFOR
		\WHILE{$|short\_peers| < table\_size$ \AND $|candidates| >0$}
			\STATE Remove the first entry $c$ from $candidates$
			\STATE Add $c$ to $short\_peers$
		\ENDWHILE
		\STATE Add $candidates$ to the set of $long\_peers$	
		\STATE \texttt{handleLongPeers}($long\_peers$)
		%\IF{$|long\_peers| > table\_size^2$}
		%	\STATE $long\_peers \leftarrow$ random subset of $long\_peers$ of size $table\_size^2$
		%\ENDIF
	\end{algorithmic}
\end{algorithm} 
%TODO We should change how to handle long peers, make it a generalizable function
%TODO Can we generalize further?

%TODO IS THIS HOW WE IMPLEMENT IT IN URDHT? DO WE CHOOSE just one peer in gossip?
%TODO short or all peers
DGVH uses the midpoint to gauge which other nodes to use as its Delaunay triangulation \cite{dgvh}.
Every maintenance cycle, nodes exchange their peer lists with\textbf{ a current neighbor and then recalculate their neighbors.  }
A node creates a list of candidates by combining their peer list with  their neighbor's peer list.
This list of peers is then sorted from closest to furthest distance.
The node then initializes a new peer list with the closest candidate.
For each of the remaining candidates, the node calculates the midpoint between itself and the candidate.
If new peer list does not contain any nodes closer to the midpoint than the candidate, the candidate is added to the new peer list.
Otherwise, the candidate is set aside.



\section{UrDHT}
\label{sec:urdht}
	\subsection{UrDHT Components (or maybe logic)}
	
	UrDHT is sectioned off into 3 components: database, network, and logic.
	Database handles file storage and network dictates the protocol for how nodes communicate.
	
	The distance and midpoints functions are defined and discussed in detail in Section \ref{sec:hyper}
	
	\subsubsection{Put and Poll}
	\subsection{Hyperbolic Routing}
	\label{sec:hyper}
	
	\subsection{Okay, this is interesting, but why bother?}
	
	Hyperbolic spaces allow us to cleanly embed scale free graphs
	
	\subsection{Wait, Nodes can move in DHTs??}
	Yes, they can.  
	There's no rule against it. 
	In fact, it helps.
	
	\subsection{Implementing Chord and Ring-Based Topology}
	
	Ring topologies are fairly straightforward since they act as are one dimensional
	
	
	\subsection{Implementing Kademlia and Other Tree Based Topologies}
	Trees are easy to embed in a hyperbolic space.
	\subsection{ZHT}
	ZHT leads to an extremely trivial implementation in UrDHT.
	
\section{Experiments}
\label{sec:experiments}

%TODO show DGVH is the bomb in 1D cause 1D is easy
\section{Future Work and Conclusions}
\label{sec:future}

\bibliography{mine,dht}
\bibliographystyle{plain}

\end{document}
