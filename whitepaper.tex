\documentclass[11pt,conference]{IEEEtran}

\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{hyperref}

\usepackage{listings}
\usepackage{subcaption}
%\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
\usepackage{algorithm} 
\usepackage{algorithmic}
\usepackage[font=small]{caption}

\title{UrDHT: A Unified Model for Distributed Hash Tables}



\author{\IEEEauthorblockN{Andrew Rosen \qquad Brendan Benshoof \qquad Robert W. Harrison \qquad Anu G. Bourgeois}
	\IEEEauthorblockA{Department of Computer Science\\
		Georgia State University\\
		Atlanta, Georgia\\
		rosen@cs.gsu.edu \qquad  bbenshoof@cs.gsu.edu  \qquad rharrison@cs.gsu.edu \qquad anu@cs.gsu.edu }
}

\hyphenation{op-tical net-works semi-conduc-tor Chord-Reduce Map-Reduce Data-Nodes Name-Nodes Ur-DHT Ur-CHORD}


\begin{document}
\lstset{language=Python} 
\maketitle

\begin{abstract}
Distributed Hash Tables (DHTs) have an inherent set qualities, such as greedy routing, maintaining lists of peers which define the topology, and form an overlay network.
Rather than having a developer be concerned with the details of a given DHT, we have constructed a new framework, UrDHT, that generalizes the functionality and implementation of various DHTs.

UrDHT is an abstract model of a Distributed Hash Table.
It maps the topologies of DHTs to the primal-dual problem of Voronoi Tessellation and Delaunay Triangulation.
By completing a few simple functions, a developer can implement the topology of any DHT in any arbitrary space using UrDHT.
For example, we implemented a DHT operating in a hyperbolic space, a previously unexplored nontrivial metric space with potential applications.

%Latency embedding will not be included in this paper
%One topology of particular interest we created is a DHT operating within a Poincar\'{e} disk model.
%This DHT could have latency embedded within the overlay and be capable of responding to changes in latency.
%The consequence of this is that, unlike other DHTs, the routing algorithm always uses the shortest latency path to a given destination.

	
\end{abstract}

\section{Introduction}
%Distributed Hash Tables (DHT) have been extensively researched for the past decade.
%Many different DHT protocols have developed over the years.
%What is a DHT
% Mention the DHT API
%Despite this, no one has created a cohesive formal specification for building a DHT. % or something


%UrDHT is our specification and implementation of an abstract DHT.



UrDHT is an abstract model of a DHT which solves a number of problems.
First, it is a unified and cohesive model for creating distributed hash tables and P2P applications based on DHTs.
Second, it provides a single network for bootstrapping distributed applications.
%Third, we show that using the abstraction features of UrDHT, we can embed latency into the DHT's overlay.
%
%\subsubsection{Abstraction}

Distributed Hash Tables have been the catalyst for the creation of many P2P applications.
Among these are Redis \cite{redis}, Freenet \cite{freenet}, and, most notably, BitTorrent \cite{bittorrent}. 
All DHTs use functionally similar protocols to perform lookup, storage, and retrieval operations.
Despite this, no one has created a cohesive formal specification for building a DHT.

Our primary motivation for this project was to create an abstracted model for Distributed Hash Tables based on observations we made during previous research \cite{dgvh}.
We found that all DHTs can cleanly be mapped to the primal-dual problems of Voronoi Tessellation and Delaunay Triangulation.

UrDHT directly builds its topology using this insight.
It uses a greedy distributed heuristic for approximating Delaunay triangulations.
UrDHT is our specification of an abstract DHT, which can be used to build many different DHTs.
We found that we could reproduce the topology of different DHTs by defining a selection heuristic and rejection algorithm for the space.
For every DHT we tried, our greedy approximation of Delaunay Triangulation using a distance and midpoint function for the space produced a stable DHT.  
This works in non-Euclidean spaces such as XOR (Kademlia)  or even a hyperbolic space represented by a Poincar\`{e} disc.

The end result is not only do we have an abstract model of DHTs, we have a simple framework that developers can use to quickly create new distributed applications.
This simple framework allows generation of internally consistent implementations of different DHTs that can have their performance rigorously compared.  %IE we can now test DHTs against each other fairly



%\subsubsection{Bootstrapping}
Another poorly addressed issue with DHTs and DHT-based P2P applications we wish to address with UrDHT is the what we have termed the \textit{bootstrapping problem}.
Simply put, a node can only join the network if it knows another node that is already a member of the network it is trying to join.
%Current distributed systems suffer from fragmentation, high overhead, and an inability to scale due to difficulty of adoption.

The general way this works is by having a potential user manually look up at a centralized source, such as the project or application's website, the bootstrapping information.
It is a philosophical conflict requiring a distributed application using a centralized source of information to build a distributed network.


UrDHT has the potential to be a distributed source for bootstrapping information for other distributed networks.
This would make new distributed applications easier to adopt by creating a network to bootstrap \textit{other networks}.
UrDHT does this by making it easy to add other networks as a service.

%\subsubsection*{Accomplishments}
To summarize our contributions:
%TODO where does bootstrapping go in the summary?
\begin{itemize}
	\item We give a formal specification for what needs to be defined in order to create a functioning DHT.
	While there has long existed a well known protocol for distributed hash tables, these define what a DHT needs to be able to do.
	It does not describe what a DHT is.
	
	We show that DHTs cleanly map to the primal-dual problem of Delaunay triangulations and Voronoi tessellations.
	We list a set  of simple functions that, once defined, allow our Distributed Greedy Voronoi Heuristic (DGVH) to be run in any space, creating a DHT overlay for that space (Section \ref{sec:define}).
	
	\item We present UrDHT as an abstract DHT and show how a developer can tweak the functions we defined to create an arbitrary new DHT topology (Section \ref{sec:urdht}).
	\item We show how to reproduce the topology of Chord and Kademlia using UrDHT, which we call UrChord and UrKademlia.
	We also implement a DHT in a hyperbolic  space represented  by a Poincar\`{e} disc (Section \ref{sec:implement}).
	%\item We show how we can embed latency into the overlay of a DHT by placing the DHT into and defining the necessary methods so that DGVH can run in that space  (Section \ref{sec:hyper}).
	
	\item We conduct experiments showing that UrChord sufficiently approximates a correct implementation of Chord (Section \ref{sec:experiments}). 
	\item We discuss the ramifications of our work and what future work is available.
\end{itemize}


\section{What Defines a DHT}
\label{sec:define}

A distributed hash table is usually defined by its protocol; in other words, what it can do.
Nodes and data in a distributed hash table are assigned unique\footnote{Unique with astronomically high probability, given a large enough consistent hash algorithm.} keys via a consistent hashing algorithm.
To make it easier to grok the context, we will call the key associated with a node its ID and refer to  nodes and their IDs interchangeably.

A DHT can perform the \texttt{lookup(key)}, \texttt{get(key)}, and \texttt{store(key, value)} operations.\footnote{There is typically a \textit{delete(key)} operation defined too, but it is not strictly necessary.}
The \texttt{lookup }operation returns the node responsible for a queried key, \texttt{get} returns the value stored with that key with the \texttt{store} function.

However, this is what a DHT \textit{does}, viewing the DHT as a black box, not what a DHT \textit{is} and needs to be implemented.
We show that Distributed Hash Tables are just Voronoi tessellations and Delaunay triangulation.


\subsection{DHT Components}
The following functions need to be defined in order for nodes to perform lookup operations and determine responsibility.

%TODO Which of theses are the discrimination metric
\begin{itemize}
	\item \textbf{A \texttt{distance} function } -
	This measures distance in the overlay formed by the Distributed Hash Table.
	In most DHTs, the distance in the overlay has no correlation with real-world attributes.
	This is not necessarily the case with UrDHT (see Section \ref{sec:hyper}).
	
	\item \textbf{A \texttt{midpoint} function} - This calculates the minimally equidistant point between two given point.
	The midpoint is required for Delaunay triangulation calculation.
	In some spaces, such as Kademlia's XOR metric space, this can be tricky to calculate.  % Is this part of ownership?
	\item \textbf{An \texttt{responsibility} definition}  This defines the range of keys a node is responsible for. 
	Not every DHT defines which node is responsible for particular keys in the same way. 
	For example, nodes in Kademlia are responsible for the keys closest to themselves, while in Chord, nodes are responsible for the keys falling between themselves and the preceding node.
\end{itemize}


A DHT also needs a strategy to organize and maintain two lists of of other nodes in the network: \textit{short peers} and \textit{long peers}.
Short peers are the set of peers that define the topology of the network and guarantee that greedy routing works.

Long peers allow the DHT to achieve a better than linear lookup time, typically $ \log(n) $, where $n$ is the size of the network. 

Interestingly, despite the diversity of DHT topologies, all DHTs use functionally identical greedy routing algorithms (Algorithm \ref{alg:routing}):

\begin{algorithm}
	\caption{The DHT Generic Routing algorithm}
	\label{alg:routing}
	\algsetup{linenosize=\tiny}
	\begin{algorithmic}[1]
		\STATE Given node $n$ and a message being sent to $key$
		\STATE \textbf{function} $n.$\texttt{lookup}$(key)$
		\IF{If $key \in n$'s range of responsibility}
			\RETURN $ n $
		\ENDIF
		\IF{ One of $n$'s short peers are responsible for $key$}
			\RETURN the responsible node
		\ENDIF
		\STATE $ candidates $ = $ short\_peers $ + $ long\_peers $
		\STATE $ next  \leftarrow $  $\min (n$.distance($candidates$, $ key ))$
		\RETURN $next.$lookup($key$)
	\end{algorithmic}
	
	\scriptsize
\end{algorithm}
If I, the node, am responsible for the key, I return myself.
Otherwise, if I know who is responsible for this key, I return that node.
Finally, if that is not the case, I forward this query to the node I know with shortest distance from the node to the desired key.\footnote{This order matters, as some DHTs such as Chord are unidirectional.} 

Between individual DHTs, this algorithm might be implemented either recursively or iteratively.
It will certainly have differences in how a node handles errors, such as how to handle connecting to a failed node which no longer exists.
This algorithm may possibly be  run in parallel, such as in Kademlia \cite{kademlia}.
Despite this, the base greedy algorithm is always the same between implementations.

The final component is a consistent hashing function.
This function must generate keys large enough to make the chances of a hash collision nigh impossible.
%LEAD INTO MULTIHASH GOES HERE



\subsection{DHTs, Delaunay Triangulation, and Voronoi Tesselation}
With the following components of a DHT defined above we can now show the relationship between DHTs and the primal-dual problems of Delaunay Triangulation and Voronoi Tessellation.

We can map a given node's ID to a point in a space, the range of keys a node is responsible for to that node's Voronoi region, and the set of short peers to the Delaunay triangulation.
Thus, if we can calculate the Delaunay triangulation between nodes in a DHT, we have a generalized means of created the overlay network.

This can be done with any algorithm that calculates the Delaunay Triangulation.
Computing the Delaunay Triangulation and/or the Voronoi Tesselation of a set of points is a well analyzed problem.
Many algorithms exist which efficiently compute a Voronoi tessellation for a given set of points on a plane, such as Fortune's sweep line algorithm \cite{fortune1987sweepline}.
However, many DHTs are distributed and many of the algorithms to compute Delaunay Triangulation and/or Delaunay Triangulation are unsuited to a distributed environment.

In addition, the computation cost increases when we move into spaces with greater than two dimensions.
In general, finding the Delaunay Triangulation of $n$ points in a space with $d$ dimensions takes $O(n^{\frac{2d-1}{d}})$ time \cite{watson1981computing}.


Is there an algorithm we can use to efficiently calculate Delaunay Triangulations for a distributed system in an arbitrary space?
We created an algorithm call the Distributed Greedy Voronoi Heuristic (DGVH), shown in Algorithm \ref{alg:dgvh} and explained below \cite{dgvh}.


\begin{algorithm} % make smaller
	\caption{Distributed Greedy Voronoi Heuristic}
	\label{alg:dgvh}
	\algsetup{linenosize=\tiny}
	%\scriptsize
	\begin{algorithmic}[1]  % the numberis how many lines
		\STATE Given node $n$ and its list of $candidates$.
		\STATE Given the minimum $table\_size$
		\STATE $short\_peers \leftarrow$ empty set that will contain $n$'s one-hop peers
		\STATE $long\_peers \leftarrow$ empty set that will contain $n$'s peers further than one hop.
		\STATE Sort $candidates$ in ascending order by each node's \texttt{distance} to $n$
		\STATE Remove the first member of $candidates$ and add it to $short\_peers$
		\FORALL{$c$ in $candidates$}
			\STATE $m$ $ \leftarrow $ \texttt{midpoint}$( n, c )$
			\IF{any node in $short\_peers$ is closer to $m$ than $n$}
				\STATE Reject $c$ as a peer
			\ELSE
				\STATE Remove $c$ from $candidates$
				\STATE Add $c$ to $short\_peers$
			\ENDIF
		\ENDFOR
		\WHILE{$|short\_peers| < table\_size$ \AND $|candidates| >0$}
			\STATE Remove the first entry $c$ from $candidates$
			\STATE Add $c$ to $short\_peers$
		\ENDWHILE
		\STATE Add $candidates$ to the set of $long\_peers$	
		\STATE \texttt{handleLongPeers}($long\_peers$)
		%\IF{$|long\_peers| > table\_size^2$}
		%	\STATE $long\_peers \leftarrow$ random subset of $long\_peers$ of size $table\_size^2$
		%\ENDIF
	\end{algorithmic}
\end{algorithm} 
%TODO short or all peers


From the perspective of the node, the candidates are the only nodes in that exist.
A node a set of peers, and uses DGVH to determine which of these correspond to Delaunay peers and form a Voronoi region
The resulting short peers are a subset of the node's actual Delaunay neighbors.
A crucial feature is that this subset guarantees that DGVH will form a routable mesh.


\subsubsection*{Algorithm  Explanation}
%TODO Reconcile with previous paper
DGVH uses the midpoint to gauge which other nodes to use as its Delaunay triangulation \cite{dgvh}.
Every maintenance cycle, nodes exchange their peer lists with their neighbors.
A node creates a list of candidates by combining their peer list with their neighbor's peer list. \footnote{In our previous paper, nodes exchange peer lists with a single peer. Calls to DGVH in this paper use all the }
This list of peers is then sorted from closest to furthest distance.
The node then initializes a new peer list with the closest candidate.
For each of the remaining candidates, the node calculates the midpoint between itself and the candidate.
If new peer list does not contain any nodes closer to the midpoint than the candidate, the candidate is added to the new peer list.
Otherwise, the candidate is set aside.
How long peers are handled depends on the particular DHT implementation.


%\subsubsection*{How do we get Candidates}
Candidates are gathered via a gossip protocol as well as notifications from close peers.
This process is described more in Section \ref{sec:protocol}.

%\subsubsection*{Sizes of short peers and long peers expected sizes and candidates}

The expected maximum size of $ candidates $ corresponds to the expected maximum degree of a vertex.
For a Delaunay Triangulation in any number of dimensions is $\Theta(\frac{\log n}{\log \log n} )$ \cite{bern1991expected}. 
We can therefore expect \textit{short peers} to be bounded by $\Theta(\frac{\log n}{\log \log n} )$.

\subsubsection*{Algorithm complexity}
%TODO square the below
The expected worst case cost of \(O(\frac{\log^{4} n}{\log^{4} \log n} )\) \cite{dgvh}, regardless of the dimension \cite{dgvh}. \footnote{As mentioned in the previous footnote, if we are exchanging peers with a single neighbor rather than all our neighbors, the cost lowers to \(O(\frac{\log^{2} n}{\log^{2} \log n} )\).}

It most cases, this cost much lower, on the order of is $ O(dk\log(k) + k^{2} ) $ for $ d $ dimensions and $ k $ candidates.

\subsubsection*{Lead to next}
We have tested DGVH on Chord (a ring-based topology), Kademlia (a XOR-based tree topology), general Euclidean spaces, and even in a hyperbolic geometry.
We show in Section \ref{sec:experiments} that DGVH works in all of these spaces.



\section{UrDHT}
\label{sec:urdht}


The name of UrDHT comes from the the German prefix \textit{ur}, which means the original. 
Our name states that all DHTs can spring from UrDHT.

UrDHT is sectioned off into 3 broad components: Storage, Networking, and Logic.
Storage handles file storage and network dictates the protocol for how nodes communicate.
These components deal with the lower level mechanics of how files are stored on the network and how bits are transmitted through the network.
The specifics are outside the scope of the paper, but can be found on the UrDHT Project \cite{urdht}.

Most of our discussion will focus on the Logic component.
The Logic component is what dictates the behavior of the DHT and the construction of the overlay network.
It is composed of two parts: the DHT Protocol and the Space Math.

The DHT Protocol is the canonical operations that a DHT performs, while the space math is what effectively distinguishes one DHT from another.
A developer only needs to change the details of the \texttt{space math} package in UrDHT to create a new type of DHT.
We discuss each in further detail below.

\subsection{The DHT Protocol }
\label{sec:protocol}

The DHT Protocol is the shared functionality between every single DHT.
It consists of the node's information, the short peer list to define the overlay, the long peers that make efficient routing possible, and all the functions that use them.




In our efforts to further abstract DHTs, we have implemented \texttt{lookup} using the function \texttt{seek}.
The \texttt{seek} function acts a single step of \texttt{lookup}.
It returns the closest node to $ key $ that the node knows about.
Nodes perform \texttt{lookup} by iteratively calling \texttt{seek} until it receives the same answer twice.


The \texttt{join} operation takes in a set of bootstrap nodes, called $ candidates $.
The joining node randomly selects one of these $ candidates $ and finds the ``parent'' node currently responsible for the space.
The joining node then populates its short peers using the ``parent'' node's short peers.
The node  uses the parent to populate its short peer list and then makes it aware of its existence using \texttt{notify}.
Once that has been finished, the joining node starts its maintenance thread.


%TODO check truth
Maintenance is done via gossip.
Each maintenance cycle, the node recalculates its Delaunay (short) peers using its neighbor's peer list 

\subsection{The Space Math}
\label{sec:space}
The space math consists of the functions which define the DHTs topology.
Essentially this is the

Space math just needs a Voronoi tessellation/ whatever creator
We provide DGVH for this, which works in every case we've tried.
If you use DGVH, here's what needs to be changed.

\subsubsection{IDToPoint}
The \texttt{idToPoint} function takes in a node's ID and any other attributes needed to map an ID onto a point in the space.

In the vast majority of DHTs, this \texttt{idToPoint} function needs nothing more than the ID as input.
The ID is directly translated into a large integer and used as a coordinate in a one dimensional space.


\subsubsection{Distance}
The \texttt{distance} function takes in two points, $a$ and $b$, and outputs the shortest distance from $a$ to $b$.
This distinction matters since distance is not symmetric in every DHT.
The prime example of this is Chord, which is a unidirectional toroidal ring.


\subsubsection{Midpoint}

Similarly to distance, \texttt{midpoint} takes in the points $ a $ and $ b $ and returns the closest midpoint\footnote{Toroidal spaces have more than one midpoint.} between the two.

\subsubsection{Get Closest}
The function \texttt{getClosest} returns the point closest to $ center$ from a list of $ candidates$, measured by the distance function.
Depending on what you want to measure, \texttt{getClosest} might measure the distance from $ center$ to each of the candidates or from each of the candidates to the $ center$.

\subsubsection{Get Delaunay (short) Peers}
We then use the above functions to implement  \texttt{getDelaunayPeers}.
Given a set of points, the $ candidates$, and a center point $ centers$, \texttt{getDelaunayPeers} calculates a mesh that of the Delaunay peers of $ center$.

We assume that this is done using DGVH, shown the Python code used
in Listing \ref{lst:dgvh}

\begin{lstlisting}[basicstyle=\footnotesize\ttfamily,  breaklines=true, caption={\texttt{getDelaunayPeers()}}, label={lst:dgvh}, frame=single] 
def getDelaunayPeers(candidates,center):    
	if len(candidates) < 2:
		return candidates
	sortedCandidates = sorted(candidates, key=lambda x: distance(x, center))
	peers = [sortedCandidates[0]] 
	sortedCandidates = sortedCandidates[1:]
	for c in sortedCandidates:
		m = midpoint(c, center)
		accept = True
		for p in peers:
			if distance(m,p) < distance(m, center):  
				accept = False
				break
		if accept:
			peers.append(c)
	return peers
\end{lstlisting}


\subsubsection{Handle Long Peers}

The final function is \texttt{handleLongPeers}.
The implementation of this function should vary greatly from one DHT to another.

In some case it may more convienent implement \texttt{handleLongPeers} as part of \texttt{getDelaunayPeers}

%\subsubsection*{Put and Poll}
%The functions of \texttt{store} and \texttt{get} can be further abstracted otu to \texttt{put} and \texttt{poll}


%This does X


\section{Implementing other DHTs}
\label{sec:implement}
\subsection{Implementing Chord and Ring-Based Topology}

Ring topologies are fairly straightforward since they act as are one dimensional Voronoi Tesselations, splitting up what is effectively a modular number line among multiple nodes.

We know Chord's invariants are not (citation), but our protocol isn't affected by these constraints


\subsection{Implementing Kademlia and Other Tree Based Topologies}
The largest complication in implementing UrKademlia is defining the exclusive or, or XOR, metric which is used for distance.
This metric, while non-euclidean, is perfectly acceptable for calculating distance in Kademlia \cite{kademlia}
However, XOR does not have an intuitive midpoint we could use for DGVH.

To solve this, we used the XOR metric defined by Kademlia as the distance function and the midpoint function.



We then implemented handle long peers.

\subsection{Implementing A Euclidean Space}


\subsection{ZHT}
ZHT \cite{li2013zht} leads to an extremely trivial implementation in UrDHT.
Unlike other DHTs, ZHT assumes an extremely low rate of churn.
As a result, the topology of ZHT is a clique, with each node having an edge to all other nodes, yielding $ O(1) $ lookup times.

The only change that needs to be made is to \texttt{handleLongPeers}.
We just place no upper bound on the size of the list of Long Peers.
\subsection{DHTs in a Hyperbolic Topology}
	
\label{sec:hyper}
	

	
	
	
	\subsection{Okay, this is interesting, but why bother?}
	Because we it was difficult
	
	Because it shows that UrDHT and DGVH both work in arbitrary geometries.
	For example, handling geographic coordinates. 
	
	
	\subsection{Wait, Nodes can move in DHTs??}
	Yes, they can.  
	There's no rule against it. 
	In fact, it helps.
	
	\subsection{Services}
	\texttt{put}  \texttt{poll}
	
\section{Experiments}
\label{sec:experiments}

We use simulations to test our DHTs.
Using simulations to test the correctness and relative performance of DHTs is standard practice in both whitepapers and applications
Citations are all major DHTs
Citations for analysis works that use simulations
Citations for applications of DHTs that were peer reviewed and accepted using simulations

What are our experiments?

\subsection{UrDHT Cohesion Euclidean Space}



\subsection{Cohesion in hyperbolic space}
We showed in worked in DGVH, it should work in a hyperbolic space.


\subsection{Performance of Chord on our network module vs UrChord}


\subsection{UrKademlia Works}


\section{Future Work and Conclusions}
\label{sec:future}

Move Latency embedding section from intro to here


%\subsubsection{Embedding}
%One of the other features shared by nearly every DHT is that routing works by minimizing the number of hops across the overlay network, with all hops treated as the same length.
%This is done because it is assumed that DHTs know nothing about the state of actual infrastructure the overlay is built upon.

%However, this means that most DHTs will happily route a message from one continent to another and back.
%This is obviously undesirable, but it is the status quo in DHTs.
%This stems from the generation of node IDs in DHTs. 
%Nodes are typically assigned a point in the range of a cryptographic hash funtion, called the keyspace. 
%This ID corresponds to the hash of some identifier or given a point randomly.
%This is done for purposes of load balancing and fault tolerance.

%We asked ourselves if there was a means of embedding latency into the DHT, while still maintaining the system's fault tolerance.
%Doing so would mean that the hops traversed to a destination are, in fact, the shortest path to the destination.

%We found that we could embed a latency graph in a hyperbolic space and defined UrDHT such that it operates within this space.
%The end result was a DHT with latency embedded into the overlay.
%Nodes can respond to changes in latency and the network by effectively moving their positions.
%We use  a force spring model to accomplish this.



Hyperbolic spaces allow us to cleanly embed scale free graphs

\bibliography{mine,dht,voronoi}
\bibliographystyle{plain}

\end{document}
